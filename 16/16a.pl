#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use feature qw(say);

my @input = (split //, '12345678');
# my @input = split //, '80871224585914546619083218645595';
# my @input = split //, '19617804207202209144916044189917';
# my @input = split //, '59755896917240436883590128801944128314960209697748772345812613779993681653921392130717892227131006192013685880745266526841332344702777305618883690373009336723473576156891364433286347884341961199051928996407043083548530093856815242033836083385939123450194798886212218010265373470007419214532232070451413688761272161702869979111131739824016812416524959294631126604590525290614379571194343492489744116326306020911208862544356883420805148475867290136336455908593094711599372850605375386612760951870928631855149794159903638892258493374678363533942710253713596745816693277358122032544598918296670821584532099850685820371134731741105889842092969953797293495';

say fft([(@input) x 10]);

sub fft {
	my ($s) = @_;
	my @signal = @$s;
	my @pattern = (0, 1, 0, -1);
	for my $phase (1 .. 100) {
		my @output;
		for my $i (0 .. $#signal) {
			my @this_pattern = (
				($pattern[0]) x ($i + 1),
				($pattern[1]) x ($i + 1),
				($pattern[2]) x ($i + 1),
				($pattern[3]) x ($i + 1),
			);
			@this_pattern = (@this_pattern) x 2 while @this_pattern < @signal + 1;
			shift @this_pattern;
			for my $j (0 .. $#signal) {
				$output[$i] //= 0;
				my $multiplier = $this_pattern[$j];
				$output[$i] += $multiplier * $signal[$j];
			}
			$output[$i] = substr $output[$i], -1;
		}
		@signal = @output;
	}
	return @signal;
}
